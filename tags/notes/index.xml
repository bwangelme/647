<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>647 Universe – Notes</title>
    <link>https://bwangel.me/647/tags/notes/</link>
    <description>Recent content in Notes on 647 Universe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Fri, 08 Sep 2017 00:24:12 +0800</lastBuildDate>
    
	  <atom:link href="https://bwangel.me/647/tags/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 算法复杂度小记</title>
      <link>https://bwangel.me/647/docs/algo/algorithm-complexity/</link>
      <pubDate>Fri, 08 Sep 2017 00:24:12 +0800</pubDate>
      
      <guid>https://bwangel.me/647/docs/algo/algorithm-complexity/</guid>
      <description>
        
        
        &lt;p&gt;本文主要书写了本人对于算法复杂度的一些理解，并辅以一些例子进行说明&lt;/p&gt;
&lt;h2 id=&#34;算法复杂度的概念&#34;&gt;算法复杂度的概念&lt;/h2&gt;
&lt;h3 id=&#34;从一个简单的例子入手&#34;&gt;从一个简单的例子入手&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cal&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;cal&lt;/code&gt; 是一个简单的求和函数, 我们将它的执行时间定义为 \( T(n) \) 。从 CPU 的角度来看，每一行代码都执行着类似的操作 &lt;strong&gt;读数据 - 运算 - 写数据&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;尽管每行代码编译出来的汇编代码都是不同的(汇编指令的个数也不同)，执行时间也都不一样。但我们这里只是粗略估计，为了简单起见，我们将每一行的代码的执行时间都定义为 &lt;code&gt;unit_time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第 2, 3 行只执行需要一个 &lt;code&gt;unit_time&lt;/code&gt;， 第4, 5行需要执行 N 个 &lt;code&gt;unit_time&lt;/code&gt;, 可以得到&lt;/p&gt;
&lt;p&gt;$$ T(n) = unit\_time * (1 + 1 + n + n) = unit\_time * (2n + 2) $$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述分析中，我们忽略了调用函数时入参和返回参数所需的时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义 \( f(n) = 2n+2 \)，由于 &lt;code&gt;unit_time&lt;/code&gt; 始终都是一个正数，&lt;strong&gt;我们可以得出 &lt;code&gt;cal&lt;/code&gt; 函数的执行时间 \( T(n) \) 和每行代码的执行次数 \( f(n) \) 成正比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上关系我们可以用 字母 &lt;code&gt;O&lt;/code&gt; 来表示:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\( T(n) = O(f(n)) ，即代码的执行时间 T(n) 和 某个函数 f(n) 成正比。\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是准确计算某个函数共有多少行代码需要执行，这也是一个困难的工作，我们可以将 &lt;code&gt;O&lt;/code&gt; 的定义进一步精确。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\( T(n) = O(f(n)) \)，代码的执行时间随着数据规模(&lt;code&gt;n&lt;/code&gt;)增长的 &lt;strong&gt;增长趋势&lt;/strong&gt;。所以，&lt;code&gt;O&lt;/code&gt; 也叫做渐进时间复杂度( asymptotic time complexity)，简称时间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度的计算理念&#34;&gt;复杂度的计算理念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们不对某个算法进行精确的分析，只需要初略地知道它的 &lt;strong&gt;增长趋势&lt;/strong&gt; 就可以了。&lt;/li&gt;
&lt;li&gt;平常我们分析算法复杂度的时候，通常有分析最坏情况和平均情况两种选项，由于最坏情况易于分析，所以我们一般分析算法复杂度的最坏情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度的渐进表示法&#34;&gt;复杂度的渐进表示法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;上界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$ T(n) = O(f(n)) $$&lt;/p&gt;
&lt;p&gt;上述式子表示当N足够大的时候，&lt;code&gt;f(n)&lt;/code&gt;函数是&lt;code&gt;T(n)&lt;/code&gt;的上界。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$ T(n) = \Omega(h(n)) $$&lt;/p&gt;
&lt;p&gt;上述式子表示当N足够大的时候，&lt;code&gt;h(n)&lt;/code&gt;函数是&lt;code&gt;T(n)&lt;/code&gt;的下界。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上界和下界同时成立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$ T(n) = \Theta(g(n)) $$&lt;/p&gt;
&lt;p&gt;上述式子表示当N足够大的时候，&lt;code&gt;g(n)&lt;/code&gt;函数同时是&lt;code&gt;T(n)&lt;/code&gt;的上界和下界。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在上面三个式子中，&lt;code&gt;T(n)&lt;/code&gt;表示的都是某个算法的时间复杂度，它们也可以应用在算法的空间复杂度&lt;code&gt;S(n)&lt;/code&gt;上。&lt;/li&gt;
&lt;li&gt;一个算法的上界和下界函数可能有无穷多个，为了和现实的情况更贴合，我们在使用上述式子表示算法的复杂度的时候，通常使用 &lt;strong&gt;最小的上界&lt;/strong&gt; 和 &lt;strong&gt;最大的下界&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度的增长趋势比较&#34;&gt;复杂度的增长趋势比较&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://passage-1253400711.cos.ap-beijing.myqcloud.com/2022-08-28-073000.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;$$ O(1) &amp;lt;  O(\log n) &amp;lt; O(n) &amp;lt; O(n \log n) &amp;lt; O(n^2) &amp;lt; O(n^3) &amp;lt; O(2^n) &amp;lt; O(n!) $$&lt;/p&gt;
&lt;p&gt;上面的复杂度量级，我们可以粗略地分成两类， 多项式量级和非多项式量级。其中，非多项式量级只有两个：指数阶 \( O(2^n) \) 和 阶乘阶 \( O(n!) \)&lt;/p&gt;
&lt;p&gt;我们把时间复杂度为非多项式量级的算法问题叫做 NP (Non-Deterministic Polynomial，非确定多项式) 问题。&lt;/p&gt;
&lt;h2 id=&#34;算法复杂度的分析规则&#34;&gt;算法复杂度的分析规则&lt;/h2&gt;
&lt;h3 id=&#34;加法法则&#34;&gt;加法法则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多个复杂度相加，取量级最大的时间复杂度&lt;/strong&gt;，这个规则用公式表示为:&lt;/p&gt;
&lt;p&gt;$$ T_1(n) = O(f_1(n)), T_2(n) = O(f_2(n)) $$&lt;/p&gt;
&lt;p&gt;$$ T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n))) $$&lt;/p&gt;
&lt;p&gt;由于我们分析算法复杂度的时候主要是分析它的 &lt;strong&gt;增长趋势&lt;/strong&gt; ，所以我们只需要分析算法复杂度的 &lt;strong&gt;某个主要趋势&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;p&gt;有时间复杂度计算公式，&lt;/p&gt;
&lt;p&gt;$$ T(n) = O(C_1 * n^2 + C_2 * n) $$&lt;/p&gt;
&lt;p&gt;\( 在N进行增长的时候，n^2 对于 T(n) 增长的影响是远远大于 n 的，所以我们就可以忽略掉 n ，认为 T(n) = O(C_1 * n^2) \)，
常数项量级也可以忽略掉，最终为&lt;/p&gt;
&lt;p&gt;$$ T(n) = O(n^2) $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即当 &lt;code&gt;n&lt;/code&gt; 很大的时候，\( n^2 为 T(n) 的上界函数。\)&lt;/li&gt;
&lt;li&gt;即随着 &lt;code&gt;n&lt;/code&gt; 的增长，某个算法所用的时间 \( T(n) \) 的 &lt;strong&gt;增长趋势&lt;/strong&gt; 是 \( n^2 \)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;\( 总结可得，当 T(n) 是关于n的k阶多项式的时候， T(n) = O(n^k) \)&lt;/p&gt;
&lt;p&gt;分析代码时，可以得出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;一个if-else的复杂度 = max(条件判断式的复杂度，if分支的复杂度，else分支的复杂度)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;忽略常数项&#34;&gt;忽略常数项&lt;/h3&gt;
&lt;p&gt;当我们谈论时间复杂度 \( \log N \) 的时候，我们并没有说明 \( \log N \) 是以2，以10还是以&lt;code&gt;e&lt;/code&gt;为底的。&lt;/p&gt;
&lt;p&gt;这是因为当N很大的时候，\( \log_{2} N  和  \log_{10} N \) 它们之间相差了常数倍。&lt;/p&gt;
&lt;p&gt;$$ log_2N = log_{10}N * log_2 10 $$&lt;/p&gt;
&lt;p&gt;其中 \( \log_2 10 \) 是一个常数&lt;/p&gt;
&lt;p&gt;\( \log N \)的增长趋势是大于常数的增长趋势的，所以我们可以忽略掉底数的差异，直接以\( \log N \) 代指一种增长趋势。&lt;/p&gt;
&lt;h3 id=&#34;乘法法则&#34;&gt;乘法法则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;嵌套代码的复杂度等一嵌套内外代码复杂度的乘积&lt;/strong&gt;，这个规则用公式表示为&lt;/p&gt;
&lt;p&gt;$$ T_1(n) = O(f_1(n)), T_2(n) = O(f_2(n)) $$&lt;/p&gt;
&lt;p&gt;$$ T_1(n) * T_2(n) = O(f_1(n) * f_2(n)) $$&lt;/p&gt;
&lt;p&gt;我们先看一段代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cal&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ret&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#000&#34;&gt;ret&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ret&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;cal&lt;/code&gt; 函数除了5行，其他地方的时间复杂度是 \( O(n) \), &lt;code&gt;f&lt;/code&gt; 函数的时间复杂度是 \( O(n) \)
整个 &lt;code&gt;cal&lt;/code&gt; 函数的时间复杂度就是&lt;/p&gt;

&lt;div class=&#34;math&#34;&gt;$$T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)$$&lt;/div&gt;&lt;p&gt;分析代码时，可得:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;一个for循环的复杂度 = 循环体的复杂度 * 循环次数
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;空间复杂度&#34;&gt;空间复杂度&lt;/h2&gt;
&lt;p&gt;上文说到, 时间复杂度的全称是 &lt;strong&gt;渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;类比一下，空间复杂度的全称就是 &lt;strong&gt;渐进空间复杂度 (asymptotic space complexity)，表示算法的存储空间和数据规模之间的增长关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看一段简单的代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;print&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;out&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码中，第二行申请了一个固定大小的内存空间，第三行申请了一个大小为 n 的 int 类型的数组，其他行都没有申请内存空间，我们可以忽略。&lt;/p&gt;
&lt;p&gt;所以整段代码的空间复杂度就是 \( O(n) \)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们常见的空间复杂度就是 \( O(1), O(n), O(n^2) \)，像 \( O(logn), O(nlogn) \) 这样的对数阶复杂度平时都用不到&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;极客时间 《数据结构与算法之美》&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.icourse163.org/course/ZJU-93001&#34;&gt;浙江大学《数据结构》公开课&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: TCP/IP 读书笔记</title>
      <link>https://bwangel.me/647/docs/tcp_ip/tcp-ip-notes/</link>
      <pubDate>Mon, 28 Aug 2017 23:50:38 +0800</pubDate>
      
      <guid>https://bwangel.me/647/docs/tcp_ip/tcp-ip-notes/</guid>
      <description>
        
        
        &lt;p&gt;本文是本人在阅读《TCP/IP 详解：卷一》时所做的一些笔记，记录一些我认为比较重要的知识点或者句子，较为凌乱，仅为本人参考使用，并非是分享知识的博客文章。&lt;/p&gt;
&lt;h2 id=&#34;第19章-tcp-的交互数据流&#34;&gt;第19章 TCP 的交互数据流&lt;/h2&gt;
&lt;h3 id=&#34;经受时延&#34;&gt;经受时延&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通常 TCP 在收到数据后并不立即进行确认，而是推迟发送 ACK 确认，以便与同一方向上的数据一起发送。有时也称这种现象为数据捎带 ACK。&lt;/li&gt;
&lt;li&gt;绝大多数实现采用的时延为200ms，即操作系统每200毫秒滴答一次，在滴答的时候 TCP 检测是否有 ACK 需要发送，如果有则发送。&lt;/li&gt;
&lt;li&gt;当一个数据包到达并被处理后，系统产生经受时延标记，ACK 暂不发送。当经受时延计时器超时后，ACK 被发送，并且系统的经受时延标记被清除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nagle-算法&#34;&gt;Nagle 算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在一个 TCP 连接上只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送任何小分组。&lt;/li&gt;
&lt;li&gt;TCP 连接将会收集这些小分组，在确认到达时以一个分组发送出去。&lt;/li&gt;
&lt;li&gt;TCP 接口可以通过&lt;code&gt;TCP_NODELAY&lt;/code&gt;选项关闭 Nagle 算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每当 TCP 接收到一个超出期望序号的失序数据时，它总是发送一个确认序号为其期望序号的确认。&lt;/li&gt;
&lt;li&gt;TCP 可以在应用读取并处理所有数据前，发送所接收数据的确认。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第20章-tcp的成块数据流&#34;&gt;第20章 TCP的成块数据流&lt;/h2&gt;
&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;发送方滑动窗口的大小随着接收方接收缓冲区的大小变化而变化。&lt;/li&gt;
&lt;li&gt;FIN 的 ACK 可以携带数据，FIN 也可以携带数据。&lt;/li&gt;
&lt;li&gt;不确定数据，仅更新窗口右边缘的 ACK 称为窗口更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;窗口大小&#34;&gt;窗口大小&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PUSH 标记
&lt;ul&gt;
&lt;li&gt;发送方通知接收方的 TCP 立即将接收到的数据发送给应用程序，这些数据包括 PSH 标记携带的数据和所有 TCP 为这个应用程序接收的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;许多 TCP 实现在窗口大小增加了两个最大报文段长度，或者窗口大小增加到最大可能窗口的50%后，会向对端发送窗口更新报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;慢启动&#34;&gt;慢启动&lt;/h3&gt;
&lt;p&gt;发送方设置一个拥塞窗口(Congestion Window)cwnd。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接建立后 cwnd = 1， 表明可以传发送方网络链路一个 MSS 大小的数据。&lt;/li&gt;
&lt;li&gt;每收到一个 ACK，cwnd++&lt;/li&gt;
&lt;li&gt;每经过一个 RTT，cwnd = cwnd * 2&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;cwnd &amp;gt;= ssthresh(slow start threshold)&lt;/code&gt;时，就会进入拥塞避免算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux 3.0以后根据 Google 一篇论文&lt;a href=&#34;http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf&#34;&gt;《An Argument for Increasing TCP’s Initial CongestionWindow》&lt;/a&gt;的建议，将 cwnd 初始化为10个 MSS。在 Linux 3.0之前，比如2.6，Linux 则采用了 &lt;a href=&#34;http://www.rfc-editor.org/rfc/rfc3390.txt&#34;&gt;RFC3390&lt;/a&gt;，cwnd 是根据 MSS 的值变化的，变化方式如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if MSS &amp;lt; 1095 {
  cwnd = 4
} else if MSS &amp;gt; 2190 {
  cwnd = 2
} else {
  cwnd = 3
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/articles/11609.html&#34;&gt;TCP 的那些事（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
      </description>
    </item>
    
  </channel>
</rss>
